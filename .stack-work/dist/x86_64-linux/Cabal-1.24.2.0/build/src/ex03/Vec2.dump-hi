
==================== FINAL INTERFACE ====================
2017-12-06 15:30:27.990747 UTC

interface funcprog-ws17-18r-0.1.0.0-EbHhfSs1oJTIKgnYUQNi6x:Vec2 8002
  interface hash: a9b07e6f1580c4405238c0c7db45cb32
  ABI hash: 37b490f7ec76ba4ee5550726c13edbdc
  export-list hash: 9e08028cc826ce90947c2f1d6aef8cb0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 27fd2797caa278c1bce07b59f758d146
  sig of: Nothing
  used TH splices: False
  where
exports:
  Vec2.scale
  Vec2.Vec2{Vec2.Vec2}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
a6d5f75e025ab159265c8bccb9e6454a
  $fEqVec2 :: GHC.Classes.Eq a => GHC.Classes.Eq (Vec2.Vec2 a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Vec2.Vec2 a)
                  (Vec2.$fEqVec2_$c== @ a $dEq)
                  (Vec2.$fEqVec2_$c/= @ a $dEq) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fEqVec2_$c/= ::
    GHC.Classes.Eq a => Vec2.Vec2 a -> Vec2.Vec2 a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Vec2.Vec2 a)
                   (y :: Vec2.Vec2 a) ->
                 GHC.Classes.not (Vec2.$fEqVec2_$c== @ a $dEq x y)) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fEqVec2_$c== ::
    GHC.Classes.Eq a => Vec2.Vec2 a -> Vec2.Vec2 a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Vec2.Vec2 a)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { Vec2.Vec2 ww1 ww2 ->
                 case w2 of ww3 { Vec2.Vec2 ww4 ww5 ->
                 Vec2.$w$c== @ a w ww1 ww2 ww4 ww5 } }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fMonoidVec2 :: GHC.Base.Monoid a => GHC.Base.Monoid (Vec2.Vec2 a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dMonoid :: GHC.Base.Monoid a).
                  @ (Vec2.Vec2 a)
                  (Vec2.$fMonoidVec2_$cmempty @ a $dMonoid)
                  (Vec2.$fMonoidVec2_$cmappend @ a $dMonoid)
                  (Vec2.$fMonoidVec2_$cmconcat @ a $dMonoid) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fMonoidVec2_$cmappend ::
    GHC.Base.Monoid a => Vec2.Vec2 a -> Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Base.Monoid a)
                   (w1 :: Vec2.Vec2 a)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { Vec2.Vec2 ww1 ww2 ->
                 case w2 of ww3 { Vec2.Vec2 ww4 ww5 ->
                 Vec2.Vec2
                   @ a
                   (GHC.Base.mappend @ a w ww1 ww4)
                   (GHC.Base.mappend @ a w ww2 ww5) } }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fMonoidVec2_$cmconcat ::
    GHC.Base.Monoid a => [Vec2.Vec2 a] -> Vec2.Vec2 a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Base.Monoid a) (w1 :: [Vec2.Vec2 a]) ->
                 case Vec2.$w$cmconcat @ a w w1 of ww { (#,#) ww1 ww2 ->
                 Vec2.Vec2 @ a ww1 ww2 }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fMonoidVec2_$cmempty :: GHC.Base.Monoid a => Vec2.Vec2 a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) ->
                 Vec2.Vec2
                   @ a
                   (GHC.Base.mempty @ a $dMonoid)
                   (GHC.Base.mempty @ a $dMonoid)) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2 :: GHC.Num.Num a => GHC.Num.Num (Vec2.Vec2 a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Vec2.Vec2 a)
                  (Vec2.$fNumVec2_$c+ @ a $dNum)
                  (Vec2.$fNumVec2_$c- @ a $dNum)
                  (Vec2.$fNumVec2_$c* @ a $dNum)
                  (Vec2.$fNumVec2_$cnegate @ a $dNum)
                  (Vec2.$fNumVec2_$cabs @ a $dNum)
                  (Vec2.$fNumVec2_$csignum @ a $dNum)
                  (Vec2.$fNumVec2_$cfromInteger @ a $dNum) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$c* ::
    GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Vec2.Vec2 a)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { Vec2.Vec2 ww1 ww2 ->
                 case w2 of ww3 { Vec2.Vec2 ww4 ww5 ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.* @ a w ww1 ww4)
                   (GHC.Num.* @ a w ww2 ww5) } }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$c+ ::
    GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Vec2.Vec2 a)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { Vec2.Vec2 ww1 ww2 ->
                 case w2 of ww3 { Vec2.Vec2 ww4 ww5 ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.+ @ a w ww1 ww4)
                   (GHC.Num.+ @ a w ww2 ww5) } }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$c- ::
    GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Num.Num a)
                   (w1 :: Vec2.Vec2 a)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { Vec2.Vec2 ww1 ww2 ->
                 case w2 of ww3 { Vec2.Vec2 ww4 ww5 ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.- @ a w ww1 ww4)
                   (GHC.Num.- @ a w ww2 ww5) } }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$cabs :: GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (ds :: Vec2.Vec2 a) ->
                 case ds of wild { Vec2.Vec2 x y ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.abs @ a $dNum x)
                   (GHC.Num.abs @ a $dNum y) }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$cfromInteger ::
    GHC.Num.Num a => GHC.Integer.Type.Integer -> Vec2.Vec2 a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (i :: GHC.Integer.Type.Integer) ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.fromInteger @ a $dNum i)
                   (GHC.Num.fromInteger @ a $dNum i)) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$cnegate :: GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (x :: Vec2.Vec2 a) ->
                 Vec2.$fNumVec2_$c-
                   @ a
                   $dNum
                   (Vec2.$fNumVec2_$cfromInteger @ a $dNum 0)
                   x) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fNumVec2_$csignum :: GHC.Num.Num a => Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (ds :: Vec2.Vec2 a) ->
                 case ds of wild { Vec2.Vec2 x y ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.signum @ a $dNum x)
                   (GHC.Num.signum @ a $dNum y) }) -}
8261282bf111e30be6d279315fd1be8c
  $fShowVec1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fShowVec2 :: GHC.Show.Show a => GHC.Show.Show (Vec2.Vec2 a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Vec2.Vec2 a)
                  (Vec2.$fShowVec2_$cshowsPrec @ a $dShow)
                  (Vec2.$fShowVec2_$cshow @ a $dShow)
                  (Vec2.$fShowVec2_$cshowList @ a $dShow) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fShowVec2_$cshow ::
    GHC.Show.Show a => Vec2.Vec2 a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Vec2.Vec2 a) ->
                 Vec2.$fShowVec2_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fShowVec2_$cshowList ::
    GHC.Show.Show a => [Vec2.Vec2 a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Vec2.Vec2 a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Vec2.Vec2 a)
                   (Vec2.$fShowVec2_$cshowsPrec @ a $dShow Vec2.$fShowVec1)
                   eta
                   eta1) -}
a6d5f75e025ab159265c8bccb9e6454a
  $fShowVec2_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Vec2.Vec2 a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Vec2.Vec2 a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Vec2.Vec2 ww3 ww4 ->
                 Vec2.$w$cshowsPrec @ a w ww1 ww3 ww4 } }) -}
46177c755ec2343dd160cf12069f401e
  $fShowVec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Vec2 "#) -}
2e4fca1360195994645c6934fa694258
  $fShowVec4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
df630d777edc9413372e8d5bc107c63f
  $tc'Vec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Vec2"#) -}
b36be0a4ad0eccf06bff60477eb736da
  $tc'Vec2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9141741375682515087##
                   3159282859267668087##
                   Vec2.$trModule
                   Vec2.$tc'Vec1) -}
371505e9bea8c6b23b4b1609066b9907
  $tcVec2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9166790301506617323##
                   5635497009245152049##
                   Vec2.$trModule
                   Vec2.$trModule1) -}
0907a8836d8ea7c77a7ae66a850d9055
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Vec2.$trModule2 Vec2.$trModule1) -}
b3a61d5e02f31c4d51acfc4b677d90d4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Vec2"#) -}
9ad3c4a58e7897b1fff2cd9626db9dee
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "funcprog-ws17-18r-0.1.0.0-EbHhfSs1oJTIKgnYUQNi6x"#) -}
1aaa87d1b2758d6780d77c546c44fabb
  $w$c== :: GHC.Classes.Eq a => a -> a -> a -> a -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),U(C(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: a)
                   (ww2 :: a)
                   (ww3 :: a) ->
                 case GHC.Classes.== @ a w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.== @ a w ww1 ww3 }) -}
a6d5f75e025ab159265c8bccb9e6454a
  $w$cmconcat :: GHC.Base.Monoid a => [Vec2.Vec2 a] -> (# a, a #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Base.Monoid a) (w1 :: [Vec2.Vec2 a]) ->
                 let {
                   z :: a = GHC.Base.mempty @ a w
                 } in
                 letrec {
                   $wgo :: [Vec2.Vec2 a] -> (# a, a #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ (w2 :: [Vec2.Vec2 a]) ->
                     case w2 of wild {
                       [] -> (# z, z #)
                       : y ys
                       -> case y of wild1 { Vec2.Vec2 x1 y1 ->
                          case $wgo ys of ww { (#,#) ww1 ww2 ->
                          (# GHC.Base.mappend @ a w x1 ww1,
                             GHC.Base.mappend @ a w y1 ww2 #) } } }
                 } in
                 $wgo w1) -}
0e436a836d1807a9c37e5f56acef070d
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> a -> a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(C(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Vec2.$fShowVec4 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Vec2.$fShowVec4 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        Vec2.$fShowVec3
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Vec2.$fShowVec3
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))))) }) -}
a6d5f75e025ab159265c8bccb9e6454a
  data Vec2 a = Vec2 a a
0a019e1c977bbd04469a1e2e0280bdf4
  scale :: GHC.Num.Num a => a -> Vec2.Vec2 a -> Vec2.Vec2 a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (fac :: a) (ds :: Vec2.Vec2 a) ->
                 case ds of wild { Vec2.Vec2 x y ->
                 Vec2.Vec2
                   @ a
                   (GHC.Num.* @ a $dNum fac x)
                   (GHC.Num.* @ a $dNum fac y) }) -}
instance [safe] GHC.Classes.Eq [Vec2.Vec2] = Vec2.$fEqVec2
instance [safe] GHC.Base.Monoid [Vec2.Vec2] = Vec2.$fMonoidVec2
instance [safe] GHC.Num.Num [Vec2.Vec2] = Vec2.$fNumVec2
instance [safe] GHC.Show.Show [Vec2.Vec2] = Vec2.$fShowVec2
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

